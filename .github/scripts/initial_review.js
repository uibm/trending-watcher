const core = require("@actions/core");
const github = require("@actions/github");
const fetch = require("node-fetch");

async function getOpenIssues(client, owner, repo) {
  const { data } = await client.rest.issues.listForRepo({
    owner, repo,
    state: "open",
    labels: "",
    per_page: 100
  });
  return data.filter(i => !i.labels.some(l => l.name === "initial review done"));
}

async function fetchReadme(owner, repo) {
  const url = `https://raw.githubusercontent.com/${owner}/${repo}/main/README.md`;
  const res = await fetch(url);
  if (res.ok) return await res.text();
  throw new Error(`Failed to fetch README (${res.status})`);
}

function summarizeMarkdown(readme) {
  const lines = readme.split("\n").slice(0, 10);
  return lines.join(" ").slice(0, 500);
}

async function run() {
  try {
    const token = process.env.GITHUB_TOKEN;
    const fullRepo = process.env.GITHUB_REPOSITORY;
    const [owner, repo] = fullRepo.split("/");

    const client = github.getOctokit(token);
    const issues = await getOpenIssues(client, owner, repo);

    for (const issue of issues) {
      const targetRepo = issue.title.replace(/^Check trending repo:\s*/, "");
      const [toOwner, toRepo] = targetRepo.split("/");
      let summary;
      try {
        const readme = await fetchReadme(toOwner, toRepo);
        summary = summarizeMarkdown(readme);
      } catch (e) {
        summary = `ðŸ“„ Could not fetch README: ${e.message}`;
      }

      const commentBody = `### ðŸ“ Initial Review Summary

**Repository:** ${targetRepo}

**README summary (first ~10 lines):**

> ${summary.replace(/\n/g, "\n> ")}

*Autoâ€‘generated by Action.*
`;

      // Add comment to issue
      await client.rest.issues.createComment({
        owner, repo,
        issue_number: issue.number,
        body: commentBody
      });

      // Add label to mark as done
      await client.rest.issues.addLabels({
        owner, repo,
        issue_number: issue.number,
        labels: ["initial review done"]
      });
    }

    core.info(`Processed ${issues.length} issue(s).`);
  } catch (err) {
    core.setFailed(err.message);
  }
}

run();
