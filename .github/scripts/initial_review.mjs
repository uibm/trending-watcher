import { getInput, setFailed, info } from "@actions/core";
import { getOctokit } from "@actions/github";
import fetch from "node-fetch";

const token = process.env.GITHUB_TOKEN;
const fullRepo = process.env.GITHUB_REPOSITORY;
const [owner, repo] = fullRepo.split("/");

const client = getOctokit(token);

async function getOpenIssues() {
  const { data } = await client.rest.issues.listForRepo({
    owner,
    repo,
    state: "open",
    labels: "",
    per_page: 100,
  });
  return data.filter(i => !i.labels.some(l => l.name === "initial review done"));
}

async function fetchReadme(toOwner, toRepo) {
  const branches = ['main', 'master'];

  for (const branch of branches) {
    try {
      const url = `https://raw.githubusercontent.com/${toOwner}/${toRepo}/${branch}/README.md`;
      const res = await fetch(url);
      if (res.ok) {
        return await res.text();
      }
    } catch (e) {
      // Try next branch
    }
  }

  throw new Error('README not found in main or master branch');
}

function summarize(readme) {
  // Remove leading whitespace and find first meaningful paragraph
  const lines = readme.split('\n').map(l => l.trim());

  // Skip initial headers, badges, images
  let startIdx = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    // Skip empty lines, headers, badges, images
    if (!line || line.startsWith('#') || line.startsWith('[![') ||
        line.startsWith('![') || line.startsWith('[!') ||
        line.match(/^<(p|div|img|a)/i)) {
      continue;
    }
    startIdx = i;
    break;
  }

  // Collect lines until we hit empty line or next section
  let paragraph = [];
  for (let i = startIdx; i < lines.length && paragraph.length < 15; i++) {
    const line = lines[i];
    if (!line && paragraph.length > 0) break; // End of paragraph
    if (line.startsWith('#')) break; // Next section
    if (line) paragraph.push(line);
  }

  return paragraph.join(' ').slice(0, 600);
}

async function run() {
  try {
    const issues = await getOpenIssues();

    for (const issue of issues) {
      const targetRepo = issue.title.replace(/^Check trending repo:\s*/, "");
      const [toOwner, toRepo] = targetRepo.split("/");

      let summary;
      try {
        const readme = await fetchReadme(toOwner, toRepo);
        summary = summarize(readme);
      } catch (e) {
        summary = `Could not fetch README: ${e.message}`;
      }

      const commentBody = `### ðŸ“ Initial Review Summary

**Repository:** ${targetRepo}

**README summary (first ~10 lines):**

> ${summary.replace(/\n/g, "\n> ")}

*Autoâ€‘generated by Action.*`;

      await client.rest.issues.createComment({
        owner, repo,
        issue_number: issue.number,
        body: commentBody,
      });

      await client.rest.issues.addLabels({
        owner, repo,
        issue_number: issue.number,
        labels: ["initial review done"],
      });
    }

    info(`Processed ${issues.length} issue(s).`);
  } catch (err) {
    setFailed(err.message);
  }
}

run();
